From 3aa31d7d6375303fc88438021aad485f50bb1e39 Mon Sep 17 00:00:00 2001
Message-Id: <3aa31d7d6375303fc88438021aad485f50bb1e39.1404919343.git.crobinso@redhat.com>
From: Marcel Apfelbaum <marcel.a@redhat.com>
Date: Mon, 23 Jun 2014 18:29:51 +0300
Subject: [PATCH] hw/pci: reserve IO and mem for pci express downstream ports
 with no devices attached

Commit c6e298e1f12e0f4ca02b6da5e42919ae055f6830
    hw/pci: reserve IO and mem for pci-2-pci bridges with no devices attached

introduced support for hot-plugging devices behind pci-2-pci bridges.
Extend hotplug support also for pci express downstream ports.

Signed-off-by: Marcel Apfelbaum <marcel.a@redhat.com>
Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
---
 src/fw/pciinit.c | 34 ++++++++++++++++++++++++++++++++--
 1 file changed, 32 insertions(+), 2 deletions(-)

diff --git a/src/fw/pciinit.c b/src/fw/pciinit.c
index 0ad548f..fd5dfb9 100644
--- a/src/fw/pciinit.c
+++ b/src/fw/pciinit.c
@@ -636,6 +636,36 @@ pci_region_create_entry(struct pci_bus *bus, struct pci_device *dev,
     return entry;
 }
 
+static int pci_bus_hotplug_support(struct pci_bus *bus)
+{
+    u8 pcie_cap = pci_find_capability(bus->bus_dev, PCI_CAP_ID_EXP);
+    u8 shpc_cap;
+
+    if (pcie_cap) {
+        u16 pcie_flags = pci_config_readw(bus->bus_dev->bdf,
+                                          pcie_cap + PCI_EXP_FLAGS);
+        u8 port_type = ((pcie_flags & PCI_EXP_FLAGS_TYPE) >>
+                       (__builtin_ffs(PCI_EXP_FLAGS_TYPE) - 1));
+        u8 downstream_port = (port_type == PCI_EXP_TYPE_DOWNSTREAM) ||
+                             (port_type == PCI_EXP_TYPE_ROOT_PORT);
+        /*
+         * PCI Express SPEC, 7.8.2:
+         *   Slot Implemented â€“ When Set, this bit indicates that the Link
+         *   HwInit associated with this Port is connected to a slot (as
+         *   compared to being connected to a system-integrated device or
+         *   being disabled).
+         *   This bit is valid for Downstream Ports. This bit is undefined
+         *   for Upstream Ports.
+         */
+        u16 slot_implemented = pcie_flags & PCI_EXP_FLAGS_SLOT;
+
+        return downstream_port && slot_implemented;
+    }
+
+    shpc_cap = pci_find_capability(bus->bus_dev, PCI_CAP_ID_SHPC);
+    return !!shpc_cap;
+}
+
 static int pci_bios_check_devices(struct pci_bus *busses)
 {
     dprintf(1, "PCI: check devices\n");
@@ -678,7 +708,7 @@ static int pci_bios_check_devices(struct pci_bus *busses)
             continue;
         struct pci_bus *parent = &busses[pci_bdf_to_bus(s->bus_dev->bdf)];
         int type;
-        u8 shpc_cap = pci_find_capability(s->bus_dev, PCI_CAP_ID_SHPC);
+        int hotplug_support = pci_bus_hotplug_support(s);
         for (type = 0; type < PCI_REGION_TYPE_COUNT; type++) {
             u64 align = (type == PCI_REGION_TYPE_IO) ?
                 PCI_BRIDGE_IO_MIN : PCI_BRIDGE_MEM_MIN;
@@ -687,7 +717,7 @@ static int pci_bios_check_devices(struct pci_bus *busses)
             if (pci_region_align(&s->r[type]) > align)
                  align = pci_region_align(&s->r[type]);
             u64 sum = pci_region_sum(&s->r[type]);
-            if (!sum && shpc_cap)
+            if (!sum && hotplug_support)
                 sum = align; /* reserve min size for hot-plug */
             u64 size = ALIGN(sum, align);
             int is64 = pci_bios_bridge_region_is64(&s->r[type],
-- 
1.9.3

